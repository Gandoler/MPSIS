Для выполнения задания, описанного выше, вам нужно следовать нескольким шагам. Давайте разберем их по порядку:

### 1. **Добавление файла `program.mem` в проект**
   - Убедитесь, что файл `program.mem` находится в папке проекта.
   - В среде разработки (например, Vivado) добавьте этот файл в раздел `Design Sources`.

### 2. **Создание модуля `CYBERcobra`**
   - Создайте новый модуль с именем `CYBERcobra` (обратите внимание на регистр).
   - Определите порты модуля в соответствии с заданием. Например:
     ```verilog
     module CYBERcobra (
         input wire clk_i,
         input wire rst_i,
         output wire [31:0] pc_o,
         output wire [31:0] instr_o,
         output wire [31:0] alu_result_o,
         output wire [31:0] reg_file_data_o
     );
     ```

### 3. **Создание счетчика команд и вспомогательных проводов**
   - Создайте счетчик команд (Program Counter, PC) и необходимые провода для управления им. Например:
     ```verilog
     reg [31:0] pc;
     wire [31:0] next_pc;
     wire [31:0] pc_plus_4;
     ```

### 4. **Создание экземпляров модулей**
   - Создайте экземпляры модулей памяти инструкций, АЛУ, регистрового файла и сумматора. Например:
     ```verilog
     imem imem_inst (
         .addr_i(pc),
         .instr_o(instr_o)
     );

     alu alu_inst (
         .a_i(reg_file_data1),
         .b_i(reg_file_data2),
         .alu_op_i(alu_op),
         .result_o(alu_result_o)
     );

     reg_file reg_file_inst (
         .clk_i(clk_i),
         .rst_i(rst_i),
         .we_i(reg_write_en),
         .addr1_i(instr_o[19:15]),
         .addr2_i(instr_o[24:20]),
         .addr3_i(instr_o[11:7]),
         .data3_i(alu_result_o),
         .data1_o(reg_file_data1),
         .data2_o(reg_file_data2)
     );

     adder adder_inst (
         .a_i(pc),
         .b_i(32'h4),
         .cin_i(1'b0),
         .sum_o(pc_plus_4)
     );
     ```

### 5. **Описание логики**
   - **Программный счетчик (PC):**
     ```verilog
     always @(posedge clk_i or posedge rst_i) begin
         if (rst_i)
             pc <= 32'h0;
         else
             pc <= next_pc;
     end
     ```

   - **Сигнал управления мультиплексором для выбора слагаемого для PC:**
     ```verilog
     assign next_pc = (branch_taken) ? branch_target : pc_plus_4;
     ```

   - **Сигнал разрешения записи в регистровый файл:**
     ```verilog
     assign reg_write_en = (instr_o[6:0] == 7'b0110011) ? 1'b1 : 1'b0;
     ```

   - **Мультиплексор для выбора слагаемого для PC:**
     ```verilog
     assign branch_target = pc + imm;
     ```

   - **Мультиплексор для выбора источника записи в регистровый файл:**
     ```verilog
     assign reg_file_data3 = (instr_o[6:0] == 7'b0110011) ? alu_result_o : imm;
     ```

### 6. **Проверка модуля с помощью верификационного окружения**
   - Убедитесь, что в `Simulation Sources` выбран корректный модуль верхнего уровня.
   - Запустите моделирование и проверьте временные диаграммы. Убедитесь, что сигналы ведут себя ожидаемо.

### 7. **Проверка работоспособности в ПЛИС**
   - Синтезируйте проект и загрузите его на ПЛИС.
   - Проверьте работоспособность схемы на реальном устройстве.

### 8. **Анализ временных диаграмм**
   - Потактово анализируйте временные диаграммы, отвечая на вопросы:
     - Какое сейчас значение программного счетчика?
     - Какая инструкция должна быть считана при данном значении программного счетчика?
     - Как должно обновиться содержимое регистрового файла в результате выполнения этой инструкции?
     - Как должен измениться программный счетчик после выполнения этой инструкции?

### Заключение
Следуя этим шагам, вы сможете создать и проверить модуль `CYBERcobra`. Убедитесь, что все сигналы и модули работают корректно, и что ваша схема ведет себя ожидаемо как в симуляции, так и на реальном устройстве.
